<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Branch-per-Feature | Adam Dymitruk</title><meta name=keywords content="Branching,Continuous Integration,DVCS,Git,Merging,Workflow"><meta name=description content="The Dymitruk Model
Following the methodology defined below is the most effective way to leverage the power of Distributed Version Control Systems - specifically Git. This work is the result of an in depth analysis of Continuous Integration and the notion of responsible Continuous Delivery. The inherent risks that de facto CI and CD introduce are mitigated by what others now refer to as &ldquo;The Dymitruk Model&rdquo;.
Features are small
Old-school branch-per-feature meant that branches were large and long living to avoid having to integrate because it was a pain. This was a vicious circle as the feature would diverge further and further from other features or the mainline. Features should be as atomic as possible and your development process should abide by the Open Close Principle. Features should be small.

You can see that the branches have a couple of commits each. We start with the end in mind with failing tests and implement the feature in the following commit. This would be the minimal amount of commits to expect on a typical feature. They won&rsquo;t typically be that small."><meta name=author content="Adam Dymitruk"><link rel=canonical href=https://blog.dymitruk.com/posts/2012-02-05-branch-per-feature/><link crossorigin=anonymous href=/assets/css/stylesheet.c2189e7d36d72767de292f8b9d897e4a464aa5bc7eb692cda50064f5eb9eeece.css integrity="sha256-whiefTbXJ2feKS+LnYl+SkZKpbx+tpLNpQBk9eue7s4=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.dymitruk.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.dymitruk.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.dymitruk.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.dymitruk.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.dymitruk.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.dymitruk.com/posts/2012-02-05-branch-per-feature/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://blog.dymitruk.com/posts/2012-02-05-branch-per-feature/"><meta property="og:site_name" content="Adam Dymitruk"><meta property="og:title" content="Branch-per-Feature"><meta property="og:description" content="The Dymitruk Model Following the methodology defined below is the most effective way to leverage the power of Distributed Version Control Systems - specifically Git. This work is the result of an in depth analysis of Continuous Integration and the notion of responsible Continuous Delivery. The inherent risks that de facto CI and CD introduce are mitigated by what others now refer to as “The Dymitruk Model”.
Features are small Old-school branch-per-feature meant that branches were large and long living to avoid having to integrate because it was a pain. This was a vicious circle as the feature would diverge further and further from other features or the mainline. Features should be as atomic as possible and your development process should abide by the Open Close Principle. Features should be small.
You can see that the branches have a couple of commits each. We start with the end in mind with failing tests and implement the feature in the following commit. This would be the minimal amount of commits to expect on a typical feature. They won’t typically be that small."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-02-05T22:38:00-08:00"><meta property="article:modified_time" content="2012-02-05T22:38:00-08:00"><meta property="article:tag" content="Branching"><meta property="article:tag" content="Continuous Integration"><meta property="article:tag" content="DVCS"><meta property="article:tag" content="Git"><meta property="article:tag" content="Merging"><meta property="article:tag" content="Workflow"><meta name=twitter:card content="summary"><meta name=twitter:title content="Branch-per-Feature"><meta name=twitter:description content="The Dymitruk Model
Following the methodology defined below is the most effective way to leverage the power of Distributed Version Control Systems - specifically Git. This work is the result of an in depth analysis of Continuous Integration and the notion of responsible Continuous Delivery. The inherent risks that de facto CI and CD introduce are mitigated by what others now refer to as &ldquo;The Dymitruk Model&rdquo;.
Features are small
Old-school branch-per-feature meant that branches were large and long living to avoid having to integrate because it was a pain. This was a vicious circle as the feature would diverge further and further from other features or the mainline. Features should be as atomic as possible and your development process should abide by the Open Close Principle. Features should be small.

You can see that the branches have a couple of commits each. We start with the end in mind with failing tests and implement the feature in the following commit. This would be the minimal amount of commits to expect on a typical feature. They won&rsquo;t typically be that small."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.dymitruk.com/posts/"},{"@type":"ListItem","position":2,"name":"Branch-per-Feature","item":"https://blog.dymitruk.com/posts/2012-02-05-branch-per-feature/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Branch-per-Feature","name":"Branch-per-Feature","description":"The Dymitruk Model Following the methodology defined below is the most effective way to leverage the power of Distributed Version Control Systems - specifically Git. This work is the result of an in depth analysis of Continuous Integration and the notion of responsible Continuous Delivery. The inherent risks that de facto CI and CD introduce are mitigated by what others now refer to as \u0026ldquo;The Dymitruk Model\u0026rdquo;.\nFeatures are small Old-school branch-per-feature meant that branches were large and long living to avoid having to integrate because it was a pain. This was a vicious circle as the feature would diverge further and further from other features or the mainline. Features should be as atomic as possible and your development process should abide by the Open Close Principle. Features should be small.\nYou can see that the branches have a couple of commits each. We start with the end in mind with failing tests and implement the feature in the following commit. This would be the minimal amount of commits to expect on a typical feature. They won\u0026rsquo;t typically be that small.\n","keywords":["Branching","Continuous Integration","DVCS","Git","Merging","Workflow"],"articleBody":"The Dymitruk Model Following the methodology defined below is the most effective way to leverage the power of Distributed Version Control Systems - specifically Git. This work is the result of an in depth analysis of Continuous Integration and the notion of responsible Continuous Delivery. The inherent risks that de facto CI and CD introduce are mitigated by what others now refer to as “The Dymitruk Model”.\nFeatures are small Old-school branch-per-feature meant that branches were large and long living to avoid having to integrate because it was a pain. This was a vicious circle as the feature would diverge further and further from other features or the mainline. Features should be as atomic as possible and your development process should abide by the Open Close Principle. Features should be small.\nYou can see that the branches have a couple of commits each. We start with the end in mind with failing tests and implement the feature in the following commit. This would be the minimal amount of commits to expect on a typical feature. They won’t typically be that small.\nIntegrate relentlessly They should be integrated into an integration branch almost as often as you commit to them. This gives feedback immediately. You have some sort of CI running off of the integration branch to tell you if your changes are not adversely affecting other work. This gives you the immediate feedback of trunk-based integration while keeping your work organized and malleable.\nYou can follow the lines here but it’s not easy as you don’t get “swim lanes” for your branches. You can see each time that we merged a feature into dev by finding the “Merge branch ‘FTR-X’ into dev”. We can use git show-branch to see what commits exist in what branches:\nJust a note that we usually make the commit messages prefixed with FTR-X which corresponds to a ticket in Jira. This way you know at a glance what feature a commit belongs to.\nDon’t do back-merges Or at least avoid them. A back-merge is where you want to use something from the integration branch to help you get your work done on the feature. This is a smell that you don’t have independent stories. A reasonable middle-ground is cherry-picking. A successfully cherry-picked commit will not cause you issues when you merge in the future.\nKeeping a feature branch filled with commits that only attain what the feature is supposed to do will make working with it much more flexible. An understanding of the DAG (directed acyclic graph) that makes up Git history will make this easy to understand.\nInvolve QA from the start This should not even be a contentious point anymore. We all know how important tight feedback loops are. There should not be a QA department with QA employees. QA should be a hat that is worn at different or same people at different times.\nKnowing what your Acceptance Criteria is and how you will prove it from the start is integral to getting a lot of things gelling - including a successful branch-per-feature regiment.\nA proper DSL a la Ubiquitous Language (see Domain Driven Design) is at the heart of this. The tool that best communicates across to the Product Owner, Regression/Specification Testing and Behaviour Driven Design feedback is currently StoryTeller. One thing that it offers that no other tools offer is communication to the person writing the Acceptance Tests of what the system is capable of doing with the smallest amount of friction caused by technology. You simply pick what you want to do by clicking on links, filling out text boxes and selecting from drop-downs. There is no guessing as to how a tool might interpret your free-form text with it’s regex and English-parsing goodness. More on this in a future post.\nA feature passes QA only if it has been integrated with all the other features that are completed. This brings us to a very light weight branch called QA or RC (release candidate). Once a feature is finished, it gets integrated to the RC branch and TeamCity or whatever CI tool you have makes a release build. This build upon being tested can throw this feature or any other back to development should they fail. Your CI tool/process will mark this with an incremented Release Candidate tag.\nYou can see that that the incomplete feature 4 is not yet part of the release candidate branch.\nHere you can list all that’s been merged into the release candidate.\nShare your hard work There will be conflicts when you merge. This is a fact of life when work is done by more than one person. When you integrate often from your feature to the integration branch, the conflicts you solve should be remembered. This is done by git’s rerere but could be simulated in other systems with little effort. The key is to set up a way of sharing these auto-resolution conflicts to the rest of the team.\nNow anyone that tries to integrate that feature and has that conflict will not have to resolve it. No dev required to put together a build. This is a manual share right now if needed. I should have the script published in about a week that does this behind the scenes. If you want to do it yourself, look no further than the .git/rr-cache folder in your repository. Simple synchronization between all devs is the bare minimum that is needed. Currently this is a branch that has it’s own branch with an independent root. Wrapping the git command to intercept fetch, pull and push makes it easy to update the rerere. Any git command can be made to look at an alternate folder for the work tree and the repository itself.\nNotice that the conflict has been marked and we resolve it by just rewriting the file to make both branches agree.\nHere, since we had rerere enabled, git records how we resolved this particular conflict. This will help us when we get to the release candidate branch and other people’s work later on.\nWhen we examine the .git folder, we can see how the resolution is stored. Just like blobs, the pre-conflict image is what determines the SHA1 hash that is the name of the directory that the conflict resolution files will be stored under. The content of these files shows just how simple even advanced concepts such as rerere are when we look at how they are implemented.\nGit now reuses our previous resolution when we had that conflict on the dev branch. It does not make this an automatic commit of the merge - just in case. We examine the file that was conflicted and are fine with it and go ahead and commit the merge.\nI’ll share the script that I’m writing once it’s finished. The resolutions get shared across a “resolutions” branch in the same repository.\nTaking features out is more powerful than putting them in This might sound counter-intuitive. But at the end of an iteration, a feature that you thought was done may not work as the last bits of testing on the build as a whole make releasing a no-go. Anyone should be able to take out that feature and release anyway.\nSo the trick is not to take the feature out of the build. You make a build with the problem feature omitted. You can integrate that feature in the next iteration when there is time. Releasing a build should be painless.\nDon’t make a build to test out of the integration branch. Make a separate branch that can be reset relentlessly and tag release candidates. Reset this branch to the start commit of your iteration and merge all the features you know work.\nNo conflicts. Remember rerere and the like? Anyone should be able to do this if you followed the practices here. This is “why” the hard work needs to be shared.\nThe key is we “threw away” all previous merges and have to redo them. But remembering our conflict resolutions, this is now a trivial matter. If in doubt, we haven’t really thrown them away, they are still there to reference or use. Git’s pick-axe functionality makes it really easy to find certain code changes if you don’t know where to look.\nHere we have decided that feature 3 is no good and we want to make a build without it:\nNow we can see that feature 3 is not part of this release candidate:\nShared code You will quickly note how painful keeping shared code synchronized across the many applications that you have. This is usually handled by git submodules. If you don’t have explicit contracts between the shared libraries and your client applications, there is going to be a lot of work to ensure you have the right version deployed. Adhering to OCP (open closed principle) is the only way out of this and buys the ability to have a rolling deployment. The preferred way is to have a submodule that contains all the messages needed to communicate in the system. You can enforce that only new messages get added with server-side hooks that will not allow existing messages to be modified or deleted - only new messages are allowed to be added.\nGiant refactorings Your work is as organized as is possible. Whether you elect to do this off of a certain point in time on the integration branch, release candidate branch or you started a feature branch for it, you have a way of tracking that work and can apply it as a merge, rebase or manual patch to another point if necessary. If there are large changes, we can do that work before we start on other features after a release. There is no magic bullet for refactoring across the board. Organized work and history help this - it doesn’t hinder it.\nAny hardships that you may encounter will be tempered by the fact that you are relentlessly sharing your conflict resolutions and continuously integrating. PROPER BRANCH-PER-FEATURE RELIES ON RELENTLESS CONTINUOUS INTEGRATION\nToggles are a hack There are exceptions. You’re a giant company. You need to enable a feature for a small subset of early adopter users. This is now an explicit feature that’s important to business. That’s where we all want to be but most of us are not.\nHaving to make architectural changes because you can’t effectively organize your work is a process smell plain and simple. Some teams are not mature enough and this may be an OK solution temporarily.\nThis is Git Flow Improved Most of this way of working started from the excellent post called “A Successful Git Branching Model”. The important addition to this process is the idea that you start all features in an iteration from a common point. This would be what you released for the last one. This drives home the granular, atomic, flexible nature that features must exhibit for us to deliver to business in the most effective way. Git flow allows commits to be done on dev branches. This workflow does not allow that.\nThe other key difference is no back-merge into the feature. Otherwise, you will not be able to exclude this feature later in the iteration.\nIt will be bad if you use old tools Not having a snapshot based history will hurt as branching is effectively copying another branch which will be slow. Not having a base of where the branch originated will make merging difficult as you do not have a base to compare how each side of development has changed. There are many other issues with having a connected-only tool to support what you do in order to work with everyone.\nWe can always deploy The release candidate builds represent production ready deployable packages. This is the most responsible way of doing Continuous Deployment. We have the latest completed and tested feature at our disposal. We don’t ship any code that does not belong to a feature that’s passed QA and all other tests. Having this option gives you the best position as an IT department. Business has the power to deploy whenever it wants to - and have the piece of mind that nothing is half-baked to the best of anyone’s knowledge.\nOld comments from Google+\n","wordCount":"2048","inLanguage":"en","datePublished":"2012-02-05T22:38:00-08:00","dateModified":"2012-02-05T22:38:00-08:00","author":{"@type":"Person","name":"Adam Dymitruk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.dymitruk.com/posts/2012-02-05-branch-per-feature/"},"publisher":{"@type":"Organization","name":"Adam Dymitruk","logo":{"@type":"ImageObject","url":"https://blog.dymitruk.com/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.dymitruk.com/ accesskey=h title="Adam Dymitruk (Alt + H)">Adam Dymitruk</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.dymitruk.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.dymitruk.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.dymitruk.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.dymitruk.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.dymitruk.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Branch-per-Feature</h1><div class=post-meta><span title='2012-02-05 22:38:00 -0800 -0800'>February 5, 2012</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>Adam Dymitruk</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-dymitruk-model aria-label="The Dymitruk Model">The Dymitruk Model</a></li><li><a href=#features-are-small aria-label="Features are small">Features are small</a></li><li><a href=#integrate-relentlessly aria-label="Integrate relentlessly">Integrate relentlessly</a></li><li><a href=#dont-do-back-merges aria-label="Don&rsquo;t do back-merges">Don&rsquo;t do back-merges</a></li><li><a href=#involve-qa-from-the-start aria-label="Involve QA from the start">Involve QA from the start</a></li><li><a href=#share-your-hard-work aria-label="Share your hard work">Share your hard work</a></li><li><a href=#taking-features-out-is-more-powerful-than-putting-them-in aria-label="Taking features out is more powerful than putting them in">Taking features out is more powerful than putting them in</a></li><li><a href=#shared-code aria-label="Shared code">Shared code</a></li><li><a href=#giant-refactorings aria-label="Giant refactorings">Giant refactorings</a></li><li><a href=#toggles-are-a-hack aria-label="Toggles are a hack">Toggles are a hack</a></li><li><a href=#this-is-git-flow-improved aria-label="This is Git Flow Improved">This is Git Flow Improved</a></li><li><a href=#it-will-be-bad-if-you-use-old-tools aria-label="It will be bad if you use old tools">It will be bad if you use old tools</a></li><li><a href=#we-can-always-deploy aria-label="We can always deploy">We can always deploy</a></li></ul></div></details></div><div class=post-content><h2 id=the-dymitruk-model>The Dymitruk Model<a hidden class=anchor aria-hidden=true href=#the-dymitruk-model>#</a></h2><p>Following the methodology defined below is the most effective way to leverage the power of Distributed Version Control Systems - specifically Git. This work is the result of an in depth analysis of Continuous Integration and the notion of <em>responsible</em> Continuous Delivery. The inherent risks that de facto CI and CD introduce are mitigated by what others now refer to as &ldquo;The Dymitruk Model&rdquo;.</p><h2 id=features-are-small>Features are small<a hidden class=anchor aria-hidden=true href=#features-are-small>#</a></h2><p>Old-school branch-per-feature meant that branches were large and long living to avoid having to integrate because it was a pain. This was a vicious circle as the feature would diverge further and further from other features or the mainline. Features should be as atomic as possible and your development process should abide by the <a href=http://en.wikipedia.org/wiki/Open/closed_principle>Open Close Principle</a>. Features should be small.</p><p><img alt="Small Branches" loading=lazy src=/images/small-branches.png></p><p>You can see that the branches have a couple of commits each. We start with the end in mind with failing tests and implement the feature in the following commit. This would be the minimal amount of commits to expect on a typical feature. They won&rsquo;t typically be that small.</p><h2 id=integrate-relentlessly>Integrate relentlessly<a hidden class=anchor aria-hidden=true href=#integrate-relentlessly>#</a></h2><p>They should be integrated into an integration branch almost as often as you commit to them. This gives feedback immediately. You have some sort of <a href=http://en.wikipedia.org/wiki/Continuous_integration>CI</a> running off of the integration branch to tell you if your changes are not adversely affecting other work. This gives you the immediate feedback of trunk-based integration while keeping your work organized and malleable.</p><p><img alt="Git Log Integration Branch" loading=lazy src=/images/git-log-integration-branch.png></p><p>You can follow the lines here but it&rsquo;s not easy as you don&rsquo;t get &ldquo;swim lanes&rdquo; for your branches. You can see each time that we merged a feature into dev by finding the &ldquo;Merge branch &lsquo;FTR-X&rsquo; into dev&rdquo;. We can use <em><a href=http://schacon.github.com/git/git-show-branch.html>git show-branch</a></em> to see what commits exist in what branches:</p><p><img alt="Git Show Branch Integration" loading=lazy src=/images/git-show-branch-integration.png></p><p>Just a note that we usually make the commit messages prefixed with FTR-X which corresponds to a ticket in <a href=http://www.atlassian.com/software/jira/overview>Jira</a>. This way you know at a glance what feature a commit belongs to.</p><h2 id=dont-do-back-merges>Don&rsquo;t do back-merges<a hidden class=anchor aria-hidden=true href=#dont-do-back-merges>#</a></h2><p>Or at least avoid them. A back-merge is where you want to use something from the integration branch to help you get your work done on the feature. This is a smell that you don&rsquo;t have independent stories. A reasonable middle-ground is <a href=http://schacon.github.com/git/git-cherry-pick.html>cherry-picking</a>. A successfully cherry-picked commit will not cause you issues when you merge in the future.</p><p>Keeping a feature branch filled with commits that only attain what the feature is supposed to do will make working with it much more flexible. An understanding of the <a href=http://eagain.net/articles/git-for-computer-scientists/>DAG (directed acyclic graph)</a> that makes up Git history will make this easy to understand.</p><h2 id=involve-qa-from-the-start>Involve QA from the start<a hidden class=anchor aria-hidden=true href=#involve-qa-from-the-start>#</a></h2><p>This should not even be a contentious point anymore. We all know how important tight feedback loops are. There should not be a QA department with QA employees. QA should be a hat that is worn at different or same people at different times.</p><p>Knowing what your Acceptance Criteria is and how you will prove it from the start is integral to getting a lot of things gelling - including a successful branch-per-feature regiment.</p><p>A proper DSL a la Ubiquitous Language (see <a href=http://domaindrivendesign.org/>Domain Driven Design</a>) is at the heart of this. The tool that best communicates across to the Product Owner, Regression/Specification Testing and <a href=http://en.wikipedia.org/wiki/Behavior_Driven_Development>Behaviour Driven Design</a> feedback is currently <a href=https://github.com/adymitruk/storyteller>StoryTeller</a>. One thing that it offers that no other tools offer is communication to the person writing the Acceptance Tests of what the system is capable of doing with the smallest amount of friction caused by technology. You simply pick what you want to do by clicking on links, filling out text boxes and selecting from drop-downs. There is no guessing as to how a tool might interpret your free-form text with it&rsquo;s regex and English-parsing goodness. More on this in a future post.</p><p>A feature passes QA only if it has been integrated with all the other features that are completed. This brings us to a very light weight branch called QA or RC (release candidate). Once a feature is finished, it gets integrated to the RC branch and <a href=http://www.jetbrains.com/teamcity/>TeamCity</a> or whatever CI tool you have makes a release build. This build upon being tested can throw this feature or any other back to development should they fail. Your CI tool/process will mark this with an incremented <em>Release Candidate</em> tag.</p><p><img alt="Release Candidate Branch" loading=lazy src=/images/release-candidate-branch.png></p><p>You can see that that the incomplete feature 4 is not yet part of the release candidate branch.</p><p><img alt="Release Candidate Tags" loading=lazy src=/images/release-candidate-tags.png></p><p>Here you can list all that&rsquo;s been merged into the release candidate.</p><h2 id=share-your-hard-work>Share your hard work<a hidden class=anchor aria-hidden=true href=#share-your-hard-work>#</a></h2><p>There will be conflicts when you merge. This is a fact of life when work is done by more than one person. When you integrate often from your feature to the integration branch, the conflicts you solve should be remembered. This is done by git&rsquo;s <a href=http://progit.org/2010/03/08/rerere.html>rerere</a> but could be simulated in other systems with little effort. The key is to set up a way of sharing these auto-resolution conflicts to the rest of the team.</p><p>Now anyone that tries to integrate that feature and has that conflict will not have to resolve it. No dev required to put together a build. This is a manual share right now if needed. I should have the script published in about a week that does this behind the scenes. If you want to do it yourself, look no further than the .git/rr-cache folder in your repository. Simple synchronization between all devs is the bare minimum that is needed. Currently this is a branch that has it&rsquo;s own branch with an independent root. Wrapping the git command to intercept fetch, pull and push makes it easy to update the rerere. Any git command can be made to look at an alternate folder for the work tree and the repository itself.</p><p><img alt="Conflict Resolution" loading=lazy src=/images/conflict-resolution.png></p><p>Notice that the conflict has been marked and we resolve it by just rewriting the file to make both branches agree.</p><p><img alt="Resolution Recording" loading=lazy src=/images/resolution-recording.png></p><p>Here, since we had rerere enabled, git records how we resolved this particular conflict. This will help us when we get to the release candidate branch and other people&rsquo;s work later on.</p><p><img alt="Resolution Storage" loading=lazy src=/images/resolution-storage.png></p><p>When we examine the .git folder, we can see how the resolution is stored. Just like blobs, the pre-conflict image is what determines the SHA1 hash that is the name of the directory that the conflict resolution files will be stored under. The content of these files shows just how simple even advanced concepts such as rerere are when we look at how they are implemented.</p><p><img alt="Resolution Replay" loading=lazy src=/images/resolution-replay.png></p><p>Git now reuses our previous resolution when we had that conflict on the dev branch. It does not make this an automatic commit of the merge - just in case. We examine the file that was conflicted and are fine with it and go ahead and commit the merge.</p><p>I&rsquo;ll share the script that I&rsquo;m writing once it&rsquo;s finished. The resolutions get shared across a &ldquo;resolutions&rdquo; branch in the same repository.</p><h2 id=taking-features-out-is-more-powerful-than-putting-them-in>Taking features out is more powerful than putting them in<a hidden class=anchor aria-hidden=true href=#taking-features-out-is-more-powerful-than-putting-them-in>#</a></h2><p>This might sound counter-intuitive. But at the end of an iteration, a feature that you thought was done may not work as the last bits of testing on the build as a whole make releasing a no-go. Anyone should be able to take out that feature and release anyway.</p><p>So the trick is not to take the feature out of the build. You make a build with the problem feature omitted. You can integrate that feature in the next iteration when there is time. Releasing a build should be painless.</p><p>Don&rsquo;t make a build to test out of the integration branch. Make a separate branch that can be reset relentlessly and tag release candidates. Reset this branch to the start commit of your iteration and merge all the features you know work.</p><p>No conflicts. Remember rerere and the like? Anyone should be able to do this if you followed the practices here. This is &ldquo;why&rdquo; the hard work needs to be shared.</p><p>The key is we &ldquo;threw away&rdquo; all previous merges and have to redo them. But remembering our conflict resolutions, this is now a trivial matter. If in doubt, we haven&rsquo;t really thrown them away, they are still there to reference or use. Git&rsquo;s pick-axe functionality makes it really easy to find certain code changes if you don&rsquo;t know where to look.</p><p>Here we have decided that feature 3 is no good and we want to make a build without it:</p><p><img alt="Remake Release Candidate" loading=lazy src=/images/remake-release-candidate.png></p><p>Now we can see that feature 3 is not part of this release candidate:</p><p><img alt="Release Candidate 4" loading=lazy src=/images/release-candidate-4.png></p><h2 id=shared-code>Shared code<a hidden class=anchor aria-hidden=true href=#shared-code>#</a></h2><p>You will quickly note how painful keeping shared code synchronized across the many applications that you have. This is usually handled by <em>git submodules</em>. If you don&rsquo;t have explicit contracts between the shared libraries and your client applications, there is going to be a lot of work to ensure you have the right version deployed. Adhering to <a href=http://en.wikipedia.org/wiki/Open/closed_principle>OCP (open closed principle)</a> is the only way out of this and buys the ability to have a rolling deployment. The preferred way is to have a submodule that contains all the messages needed to communicate in the system. You can enforce that only new messages get added with <a href=http://progit.org/book/ch7-3.html>server-side hooks</a> that will not allow existing messages to be modified or deleted - only new messages are allowed to be added.</p><h2 id=giant-refactorings>Giant refactorings<a hidden class=anchor aria-hidden=true href=#giant-refactorings>#</a></h2><p>Your work is as organized as is possible. Whether you elect to do this off of a certain point in time on the integration branch, release candidate branch or you started a feature branch for it, you have a way of tracking that work and can apply it as a merge, rebase or manual patch to another point if necessary. If there are large changes, we can do that work before we start on other features after a release. There is no magic bullet for refactoring across the board. Organized work and history help this - it doesn&rsquo;t hinder it.</p><p>Any hardships that you may encounter will be tempered by the fact that you are relentlessly sharing your conflict resolutions and continuously integrating. <strong>PROPER BRANCH-PER-FEATURE RELIES ON RELENTLESS CONTINUOUS INTEGRATION</strong></p><h2 id=toggles-are-a-hack>Toggles are a hack<a hidden class=anchor aria-hidden=true href=#toggles-are-a-hack>#</a></h2><p>There are exceptions. You&rsquo;re a giant company. You need to enable a feature for a small subset of early adopter users. This is now an explicit feature that&rsquo;s important to business. That&rsquo;s where we all want to be but most of us are not.</p><p>Having to make architectural changes because you can&rsquo;t effectively organize your work is a process smell plain and simple. Some teams are not mature enough and this may be an OK solution temporarily.</p><h2 id=this-is-git-flow-improved>This is Git Flow Improved<a hidden class=anchor aria-hidden=true href=#this-is-git-flow-improved>#</a></h2><p>Most of this way of working started from the excellent post called <a href=http://nvie.com/posts/a-successful-git-branching-model/>&ldquo;A Successful Git Branching Model&rdquo;</a>. The important addition to this process is the idea that you start all features in an iteration from a common point. This would be what you released for the last one. This drives home the granular, atomic, flexible nature that features must exhibit for us to deliver to business in the most effective way. Git flow allows commits to be done on dev branches. This workflow does not allow that.</p><p>The other key difference is no back-merge into the feature. Otherwise, you will not be able to exclude this feature later in the iteration.</p><h2 id=it-will-be-bad-if-you-use-old-tools>It will be bad if you use old tools<a hidden class=anchor aria-hidden=true href=#it-will-be-bad-if-you-use-old-tools>#</a></h2><p>Not having a snapshot based history will hurt as branching is effectively copying another branch which will be slow. Not having a base of where the branch originated will make merging difficult as you do not have a base to compare how each side of development has changed. There are many other issues with having a connected-only tool to support what you do in order to work with everyone.</p><h2 id=we-can-always-deploy>We can always deploy<a hidden class=anchor aria-hidden=true href=#we-can-always-deploy>#</a></h2><p>The release candidate builds represent production ready deployable packages. This is the most responsible way of doing Continuous Deployment. We have the latest completed and tested feature at our disposal. We don&rsquo;t ship any code that does not belong to a feature that&rsquo;s passed QA and all other tests. Having this option gives you the best position as an IT department. Business has the power to deploy whenever it wants to - and have the piece of mind that nothing is half-baked to the best of anyone&rsquo;s knowledge.</p><p><a href=http://www.dymitruk.com/old-comments-about-branch-per-feature.html>Old comments from Google+</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.dymitruk.com/tags/branching/>Branching</a></li><li><a href=https://blog.dymitruk.com/tags/continuous-integration/>Continuous Integration</a></li><li><a href=https://blog.dymitruk.com/tags/dvcs/>DVCS</a></li><li><a href=https://blog.dymitruk.com/tags/git/>Git</a></li><li><a href=https://blog.dymitruk.com/tags/merging/>Merging</a></li><li><a href=https://blog.dymitruk.com/tags/workflow/>Workflow</a></li></ul><nav class=paginav><a class=prev href=https://blog.dymitruk.com/posts/2012-06-09-ndc-oslo/><span class=title>« Prev</span><br><span>NDC Oslo</span>
</a><a class=next href=https://blog.dymitruk.com/posts/2012-01-25-a-fresh-start-octopress/><span class=title>Next »</span><br><span>A Fresh Start: Octopress Provides the Tooling for Blogging</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Branch-per-Feature on x" href="https://x.com/intent/tweet/?text=Branch-per-Feature&amp;url=https%3a%2f%2fblog.dymitruk.com%2fposts%2f2012-02-05-branch-per-feature%2f&amp;hashtags=Branching%2cContinuousIntegration%2cDVCS%2cGit%2cMerging%2cWorkflow"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Branch-per-Feature on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.dymitruk.com%2fposts%2f2012-02-05-branch-per-feature%2f&amp;title=Branch-per-Feature&amp;summary=Branch-per-Feature&amp;source=https%3a%2f%2fblog.dymitruk.com%2fposts%2f2012-02-05-branch-per-feature%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Branch-per-Feature on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.dymitruk.com%2fposts%2f2012-02-05-branch-per-feature%2f&title=Branch-per-Feature"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Branch-per-Feature on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.dymitruk.com%2fposts%2f2012-02-05-branch-per-feature%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Branch-per-Feature on whatsapp" href="https://api.whatsapp.com/send?text=Branch-per-Feature%20-%20https%3a%2f%2fblog.dymitruk.com%2fposts%2f2012-02-05-branch-per-feature%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Branch-per-Feature on telegram" href="https://telegram.me/share/url?text=Branch-per-Feature&amp;url=https%3a%2f%2fblog.dymitruk.com%2fposts%2f2012-02-05-branch-per-feature%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Branch-per-Feature on ycombinator" href="https://news.ycombinator.com/submitlink?t=Branch-per-Feature&u=https%3a%2f%2fblog.dymitruk.com%2fposts%2f2012-02-05-branch-per-feature%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.dymitruk.com/>Adam Dymitruk</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>